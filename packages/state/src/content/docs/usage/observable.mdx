---
title: Observable
sidebar:
  order: 1
---

You can put anything in an observable: primitives, deeply nested objects, arrays, functions, etc... Observables work just like normal objects so you can interact with them without any extra complication. Just call `get()` to get a value and `set(...)` to modify it.

:::note
We use a `$` suffix on variables as a convention to indicate an observable but it's not required.
:::

```js
import { observable } from "@legendapp/state"

const state$ = observable({
    fname: 'Annyong',
    lname: 'Bluth',
    name: () => state$.fname.get() + ' ' + state$.lname.get()
})

// get
const value = state$.get()
// set
state$.fname.set('Hello')
// assign to an object
state$.assign({ fname: 'Maebe' })
// any function can be used as a computed observable
const name = state$.name.get()
```

## Observable methods

### get()

Observables use [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) to expose observable functions and track changes, so an observable is a Proxy pointing to the actual data. You can use `get()` to get the actual value of any observable.

```js
const profile = { name: "Test user" }
const state$ = observable({ profile: profile, test: 0 })

// The raw value is unchanged
state$.profile.get() // { name: 'Test user' }
state$.profile === profile // ❌ false. The observable is not strictly equal to profile.
state$.profile.get() === profile // ✅ true. The raw data is exactly what was set.
```

Accessing properties through the observable will create a Proxy for every property accessed, but it will not do that while accessing the raw data. So you may want to retrieve the raw data before doing expensive computations that do not need to notify.

```js
const state$ = observable({ data: someHugeThing })
const { data } = state$.get()

// Nothing special happens when working with the raw data
processData(data)
```

Calling `get()` within a tracking context tracks the observable automatically. You can change that behavior with a parameter `true` to track only when keys are added/removed. See [observing contexts](../reactivity/#observing-contexts) for more details.

```js
state$.get(true) // Create a shallow listener
```

### peek()

`peek()` returns the raw value in the same way as `get()`, but it does not automatically track it. Use this when you don't want the component/observing context to update when the value changes.

### set()

You can use `set()` to modify the observable, at any path within it. You can even `set()` on a node that is currently undefined, and it will fill in the object tree to make it work.

```js
const state$ = observable({ text: "hi" })

// Set directly
state$.text.set("hello there")

// Set with a function relative to previous value
state$.text.set((prev) => prev + " there")

// Set will automatically fill out objects that were undefined
state$.otherKey.otherProp.set("hi")
```

### assign()

Assign is a shallow operation matching `Object.assign` to set multiple properties at once. If you want a deep merge, see [mergeIntoObservable](../helper-functions/#mergeintoobservable). These batch all individual set operations so that observers only update once.

```js
const state$ = observable({ text: "hi" })

// Assign
state$.assign({ text: "hi2" })
```

### delete()

Observables provide a `delete` function to delete a key from an object.

```js
const state$ = observable({ text: "hi" })

// Delete text
state$.text.delete()

// Set the whole value to undefined
state$.delete()
```

`delete` works on array elements as well, removing the element from the array.

```js
const state$ = observable([ 'apple', 'orange' ])

// Delete from the array
state$[0].delete()
// state === ['orange']
```


## Computed Observables

### Functions

Observables can have functions anywhere within them. You can use these for whatever you want, such as adding extra behavior when setting.

```js
const state$ = observable({
    isReady: false,
    toggle: () => {
        state$.isReady.toggle()
        console.log('set to', state$.isReady.get())
    }
})
```

[Observing contexts](../reactivity/#observing-contexts) track all observable `get()` calls, including within any called functions.

```jsx
const state$ = observable({
    fname: 'Annyong',
    lname: 'Bluth',
    fullName: () => state$.fname.get() + ' ' + state$.lname.get()
})

const Name = observer(function Name() {
    // Tracks [state$.fname, state$.lname]
    const name = state$.fullName()
    return <div>{name}</div>
})
```

### Computed Functions

Any function in an observable can be used a computed observable, whether at the root or in any child. A function is turned into an observable when you first call `get()` or `peek()` on it. It will then re-compute itself whenever the observables it accesses with `get()` are changed.

```js
const state$ = observable({
    fname: 'Annyong',
    lname: 'Bluth',
    // A child is computed
    fullName: () => state$.fname.get() + ' ' + state$.lname.get()
})
// An observable with a function is a computed
const name$ = observable(() => state$.fname.get() + ' ' + state$.lname.get())
```

```js
// A normal function returns the value and computes when called.
const fullName = state$.fullName()

// Calling .get() activates a computed observable that recomputes itself on changes
const reactiveFullName = state$.fullName.get()
```

The difference between using it as a function vs. as a computed observable is that a computed observable is an object that caches the value.
- `fullName()` is a function that re-compute whenever you call it.
- `fullName.get()` creates a computed observable that re-computes itself whenever its dependencies change.

## Async Observables

Creating an observable with a Promise or async function will initialize it to `undefined`, and it will be updated with the value of the Promise when it resolves.

```js
const serverState$ = observable(() => fetch('url').then(res => res.json()))

observe(() => {
    // Getting the value activates the observable to fetch, and it
    //  updates its value when it resolves.
    const data = serverState$.get()
    if (data) {
        ...
    }
})
```

Asynchronous observables pair very well with [when](../../usage/reactivity/#when) to activate the function and resolve when the observable's Promise is resolved.

```js
// Await the promise to resolve and then get the data from it
const data = await when(serverState$)
console.log(data)
```

You can access the status of an async observable with the [syncState](../../usage/persist-sync/#syncstate) helper, which is an observable itself. The most common usage is to check its loaded or error states:

```js
const status$ = syncState(serverState$)
observe(() => {
    // This will re-run as the status changes
    const { isLoaded, error } = status$.get()
    if (error) {
        // Handle error
    } else if (isLoaded) {
        // Do the thing
    }
})
```

## Linked observables

### Two-Way Linked

`linked` creates an observable bound to both `get` and `set` functions. This lets you bind or transform a single or multiple other observable values. For example it could be used to create a "Select All" checkbox.

```js
import { linked, observable } from "@legendapp/state"

const selected$ = observable([false, false, false])
const selectedAll$ = observable(linked({
  // selectedAll is true when every element is selected
  get: () => selected$.every((val$) => val$.get()),

  // setting selectedAll sets the value of every element
  set: (value) => selected$.forEach((val$) => val$.set(value))
}))

selectedAll$.set(true)
// selected.get() === [true, true, true]
```

Or it could be used to automatically deserialize/serialize a string value.

```js
const str$ = observable('[1,2,3]')
const arr$ = observable(linked({
  get: () => JSON.parse(arr$.get())
  set: (value) => arr$.set(JSON.stringify(value))
}))
```

#### Initial value

When creating an asynchronous observable with a Promise you may want it to have an initial default value until the promise resolves. You can use the `initial` property of `linked` to do that.

```js
import { linked } from "@legendapp/state"

const state$ = observable(linked({
    get: () => fetch('url').then(res => res.json()),
    initial: { numUsers: 0, messages: [] }
}))
```

## Advanced Computeds

### Link to another observable

If you return an observable from a computed function, it will create a two-way link to the target observable. Interacting with that observable will then pass through to the target.

Observing contexts tracking the linking observable will be re-run both when the linked observable's value changes and when the link itself changes.

In this example, the observable that `selectedItem` points to is changed by setting `selectedIndex`. And because it's a direct link to the target observable, `set` operations will pass through to the target observable.

```js
const state$ = observable({
  items: ["hi", "there", "hello"],
  selectedIndex: 0,
  selectedItem: () => state$.items[state$.selectedIndex.get()],
})

observe(() => {
    console.log('observe:' + state$.selectedItem.get())
})
// observe: 'hi'

state$.selectedIndex.set(2)
// observe: 'hello'

state$.selectedItem.set('HELLO!')
// observe: 'HELLO!'
```

### Lookup table

A function with a single `string` key can be used as a lookup table (an object with a string key). Accessing it by index will call the function to create a computed observable by that key.

```ts
const state$ = observable({
  selector: 'text',
  items: { test1: { text: 'hi', othertext: 'bye' }, test2: { text: 'hello', othertext: 'goodbye' } },
  // Return a link to the [selector] property in the given item
  texts: (key: string) => {
    return state$.items[key][obs.selector.get()]
  },
})

// Now these reference the same thing:
state$.items.test1.text.get()
state$.texts['test1'].get()
```

### event

`event` works like an observable without a value. You can listen for changes as usual, and dispatch it manually whenever you want. This can be useful for simple events with no value, like onClosed.

```js
import { event } from "@legendapp/state"

const onClosed = event()

// Simply pass a callback to the `on` function
onClosed.on(() => { ... })

// Or use it with 'onChange' like other observables
onClosed.onChange(() => { ... })

// Dispatch the event to call listeners
onClosed.fire()
```

## Notes

### Safety

Observables are safe so that you cannot directly assign to them, which prevents accidentally overwriting state or accidentally assigning huge objects into an observable.

```js
const state$ = observable({ text: "hello", num: 10, obj: {} }, /*safe*/ true)

state$.text = "hi"
// ❌ Can't set directly

state$.text.set("hi")
// ✅ Calling set on a primitive works.

state$ = {}
// ❌ Error. This would delete the observable.

state$.obj = {}
// ❌ Error. Cannot assign to objects directly.

state$.set({ text: "hi", num: 20 })
// ✅ Calling set on an object works.

state$.assign({ text: "hello there" })
// ✅ Calling assign on an object works.

state$.text.assign({ value: "hello there" })
// ❌ Error. Cannot call assign on a primitive.
```

If you really want to assign directly to observables, there is an extension to add `$` as a property you can get/set. See [configuration](../configuring#enable$get) for details.

```js
const testValue = state$.test.$

// Assign to $ as a shorthand for set()
state$.test.$ = "hello"

// Assign objects too just like you can with set()
state$.$ = { test: "hello" }
```

### undefined

Because observables track nodes [by path](../../intro/fast/#proxy-to-path) and not the underlying data, an observable points to a path within an object regardless of its actual value. So it is perfectly fine to access observables when they are currently undefined in the object.

You could to do this to set up a listener to a field whenever it becomes available.

```jsx
const state$ = observable({ user: undefined })

when(state$.user.uid, (uid) => {
  // Handle login
})
```

Or you could set a value inside an undefined object, and it will fill out the object tree to make it work.

```jsx
const state$ = observable({ user: undefined })

observe(() => {
  // This will be undefined until the full user profile is set
  console.log(`Name: ${state$.user.profile.name.get()}`)
})

state$.user.profile.name.set("Annyong")

// state$ == { user: { profile: { name: 'Annyong' } } }
```

### Arrays

Observable arrays have all of the normal array functions as you'd expect, but some are modified for observables.

All looping functions set up [shallow tracking](../reactivity#shallow-modifier) automatically, as well as provide the observable in the callback. This includes:

- every
- filter
- find
- findIndex
- forEach
- includes
- join
- map
- some

Additionally, `filter` returns an array of observables and `find` returns an observable (or undefined).

If you don't want this extra observable behavior, `get()` or `peek()` the observable to get the raw array to act on.

### Observables are mutable

Legend-State does not use immutability because immutability is slow. It needs to do deep equality checking of changes to know which nodes to notify anyway, so immutability just isn't needed. So there are two things to be careful of.

#### 1. Modifying raw data breaks notifying of changes.

Observables are just wrappers around the underlying data, so if you modify the raw data you're actually modifying the observable data without notifying of changes. Then if you set it back onto the observable, that just sets it to itself so nothing happens.

```js
// ❌ This sets it to itself, nothing happens
const value = state$.get()
value.key = 'newValue'
state$.set(value)

// ✅ Set the value directly in the observable
state$.key.set('newValue')

// ✅ Assign the key/value to the observable
state$.assign({ key: 'newValue' })
```

#### 2. Don't need to clone

A common pattern in React is to set state with a clone of the previous value, which is required because of immutability constraints in React. Legend-State does not have that constraint, and cloning is bad for performance, so it's better to do operations directly on the observables.

```js
// ❌ Setting with a cloned object creates a new object unnecessarily
const record = record$.get()
const newRecord = { ...record, key: 'value' }
record$.set(newRecord)

// ✅ Set the key directly in the observable
record$.key.set('value')
```

```js
// ❌ Setting with a cloned array creates a new array unnecessarily
const list = list$.get()
const newList = [ ...list, 'value' ]
list$.set(newList)

// ✅ Just push it
list$.push('value')
```

```js
// ❌ Delete by clone and destructure creates a new object unnecessarily
const record = record$.get()
const { key, ...rest } = record
record$.set(rest)

// ✅ Delete the key directly in the observable
record$.key.delete()
```

```js
// ❌ Setting a filtered array creates a new array unnecessarily
const list = list$.get()
const newList = list.filter((item) => item.id != itemId)
list$.set(newList)

// ✅ Delete it from the array directly
const list = list$.get()
const idx = list.findIndex((item) => item.id === itemId)
list$[idx].delete()
```
